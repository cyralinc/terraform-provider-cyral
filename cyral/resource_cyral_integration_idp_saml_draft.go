package cyral

import (
	"context"
	"fmt"
	"log"
	"net/http"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/cyralinc/terraform-provider-cyral/client"
)

// Note that although the IdP type is SAML as seen from the control plane UI, we
// use GenericSAML in many variables, to make it more specific.
//
// The SAML IdP type is different from all others, in that it is _generic_. It
// allows the user to configure any type of IdP integration, as long as they
// provide the IdP metadata.
//
// This resource only covers the _draft_ of the integration. The draft is
// created on the control plane, and the SP metadata is generated. To complete
// the draft, one must perform the following steps:
//
// 1. Provide the SP metadata generated by this resource to the IdP.
//
// 2. Provide the IdP metadata to the `cyral_integration_idp_saml` resource.
//

type CreateGenericSAMLDraftRequest struct {
	DisplayName              string `json:"displayName"`
	DisableIdPInitiatedLogin bool   `json:"disableIdPInitiatedLogin"`
	IdpType                  string `json:"idpType,omitempty"`
	*RequiredUserAttributes  `json:"attributes,omitempty"`
}

func (req *CreateGenericSAMLDraftRequest) ReadFromSchema(d *schema.ResourceData) error {
	req.DisplayName = d.Get("display_name").(string)
	req.DisableIdPInitiatedLogin = d.Get("disable_idp_initiated_login").(bool)
	req.IdpType = d.Get("idp_type").(string)

	attributes, err := RequiredUserAttributesFromSchema(d)
	if err != nil {
		return err
	}
	req.RequiredUserAttributes = attributes

	return nil
}

type GenericSAMLDraftResponse struct {
	Draft GenericSAMLDraft `json:"draft"`
}

func (resp *GenericSAMLDraftResponse) WriteToSchema(d *schema.ResourceData) error {
	d.SetId(resp.Draft.ID)
	if err := d.Set("display_name", resp.Draft.DisplayName); err != nil {
		return err
	}
	if err := d.Set("disable_idp_initiated_login", resp.Draft.DisableIdPInitiatedLogin); err != nil {
		return err
	}
	if err := d.Set("sp_metadata", resp.Draft.SPMetadata.XMLDocument); err != nil {
		return err
	}
	if err := d.Set("idp_type", resp.Draft.IdpType); err != nil {
		return err
	}
	if resp.Draft.RequiredUserAttributes != nil {
		if err := resp.Draft.RequiredUserAttributes.WriteToSchema(d); err != nil {
			return err
		}
	}
	return nil
}

func CreateGenericSAMLDraftConfig() ResourceOperationConfig {
	return ResourceOperationConfig{
		Name:       "GenericSAMLDraftResourceCreate",
		HttpMethod: http.MethodPost,
		CreateURL: func(d *schema.ResourceData, c *client.Client) string {
			return fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts", c.ControlPlane)
		},
		NewResourceData: func() ResourceData { return &CreateGenericSAMLDraftRequest{} },
		NewResponseData: func(_ *schema.ResourceData) ResponseData { return &GenericSAMLDraftResponse{} },
	}
}

func ReadGenericSAMLDraftConfig() ResourceOperationConfig {
	return ResourceOperationConfig{
		Name:       "GenericSAMLDraftResourceRead",
		HttpMethod: http.MethodGet,
		CreateURL: func(d *schema.ResourceData, c *client.Client) string {
			return fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts/%s", c.ControlPlane, d.Id())
		},
		NewResponseData: func(_ *schema.ResourceData) ResponseData { return &GenericSAMLDraftResponse{} },
	}
}

func resourceIntegrationIdPSAMLDraftDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	log.Printf("[DEBUG] Init resourceIntegrationIdPSAMLDelete")
	c := m.(*client.Client)

	url := fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts/%s",
		c.ControlPlane, d.Id())
	_, err := c.DoRequest(url, http.MethodDelete, nil)
	if err != nil {
		httpError, ok := err.(*client.HttpError)
		if !ok || httpError.StatusCode != http.StatusNotFound {
			return createError("Unable to delete SAML draft", err.Error())
		}
		log.Printf("[DEBUG] SAML draft not found. Skipping deletion.")
		// If the HTTP status is NotFound, it means we don't need to
		// worry about deleting anything.
	}

	log.Printf("[DEBUG] End resourceIntegrationIdPSAMLDelete")

	return diag.Diagnostics{}
}

func resourceIntegrationIdPSAMLDraft() *schema.Resource {
	return &schema.Resource{
		Description: "Manages SAML IdP integration drafts.",
		CreateContext: CreateResource(
			CreateGenericSAMLDraftConfig(),
			ReadGenericSAMLDraftConfig(),
		),
		ReadContext:   ReadResource(ReadGenericSAMLDraftConfig()),
		DeleteContext: resourceIntegrationIdPSAMLDraftDelete,
		Schema: map[string]*schema.Schema{
			// All of the input arguments must force recreation of
			// the resource, because the API does not support
			// updates. If you try to use the Create API to do
			// updates, it will create a new SAML draft altogether,
			// generating a new ID etc.
			"display_name": {
				Description:  "Display name used in the Cyral control plane.",
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringIsNotEmpty,
				ForceNew:     true,
			},
			"disable_idp_initiated_login": {
				Description: "Whether or not IdP-Initiated login should be disabled for this generic SAML integration draft. Defaults to false.",
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Default:     false,
			},
			"idp_type": {
				Description: "Identity provider type. The value provided can be used as a filter when retrieving SAML integrations. See data source `cyral_integration_idp_saml`.",
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Default:     "saml-provider",
			},
			"attributes": {
				Description: "SAML Attribute names for the identity attributes required by the Cyral SP. Each attribute name MUST be at least 3 characters long.",
				Type:        schema.TypeSet,
				// This needs to be required. Otherwise, if the
				// user omits it, the API will still return the
				// attributed filled with the default
				// values. Then, when trying to run `terraform
				// apply` again, the resource will always be
				// recreated, since a change will be detected.
				//
				// One option would be to have the attributes
				// laid at the top level, like
				// `attribute_first_name`, `attribute_last_name`
				// etc. But that doesn't look good, and then the
				// resource would not reflect the API fields so
				// well.
				Required: true,
				ForceNew: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"first_name": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users first name (given name). Defaults to `firstName`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      "firstName",
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"last_name": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users last name (family name). Defaults to `lastName`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      "lastName",
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"email": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users email address. Defaults to `email`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      "email",
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"groups": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users group membership in the IdP. Defaults to `memberOf`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      "memberOf",
							ValidateFunc: validationStringLenAtLeast(3),
						},
					},
				},
			},
			"sp_metadata": {
				Description: "The SP Metadata document describing the Cyral service provider for this integration.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"id": {
				Description: "ID of this resource in the Cyral environment.",
				Type:        schema.TypeString,
				Computed:    true,
			},
		},
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
	}
}
