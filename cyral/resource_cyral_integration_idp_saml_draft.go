package cyral

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/cyralinc/terraform-provider-cyral/client"
)

// Note that although the IdP type is SAML as seen from the control plane UI, we
// use GenericSAML in many variables, to make it more specific.
//
// The SAML IdP type is different from all others, in that it is _generic_. It
// allows the user to configure any type of IdP integration, as long as they
// provide the IdP metadata.
//
// This resource only covers the _draft_ of the integration. The draft is
// created on the control plane, and the SP metadata is generated. To complete
// the draft, one must perform the following steps:
//
// 1. Provide the SP metadata generated by this resource to the IdP.
//
// 2. Provide the IdP metadata to the `cyral_integration_idp_saml` resource.
//

type CreateGenericSAMLDraftRequest struct {
	DisplayName              string                  `json:"displayName"`
	DisableIdPInitiatedLogin bool                    `json:"disableIdPInitiatedLogin"`
	IdpType                  string                  `json:"idpType,omitempty"`
	Attributes               *RequiredUserAttributes `json:"attributes,omitempty"`
}

func (req *CreateGenericSAMLDraftRequest) ReadFromSchema(d *schema.ResourceData) error {
	req.DisplayName = d.Get("display_name").(string)
	req.DisableIdPInitiatedLogin = d.Get("disable_idp_initiated_login").(bool)
	req.IdpType = d.Get("idp_type").(string)

	attributes, err := RequiredUserAttributesFromSchema(d)
	if err != nil {
		return err
	}
	req.Attributes = attributes

	return nil
}

type GenericSAMLDraftResponse struct {
	Draft GenericSAMLDraft `json:"draft"`
}

func (resp *GenericSAMLDraftResponse) WriteToSchema(d *schema.ResourceData) error {
	d.SetId(resp.Draft.ID)
	if err := d.Set("display_name", resp.Draft.DisplayName); err != nil {
		return err
	}
	if err := d.Set("disable_idp_initiated_login", resp.Draft.DisableIdPInitiatedLogin); err != nil {
		return err
	}
	if err := d.Set("sp_metadata", resp.Draft.SPMetadata.XMLDocument); err != nil {
		return err
	}
	if err := d.Set("idp_type", resp.Draft.IdpType); err != nil {
		return err
	}
	if resp.Draft.Attributes != nil && typeSetNonEmpty(d, "attributes") {
		if err := d.Set("attributes", resp.Draft.Attributes.ToInterface()); err != nil {
			return err
		}
	}
	return nil
}

type ListGenericSAMLDraftsResponse struct {
	Drafts []GenericSAMLDraft `json:"drafts"`
}

func CreateGenericSAMLDraftConfig() ResourceOperationConfig {
	return ResourceOperationConfig{
		Name:       "GenericSAMLDraftResourceCreate",
		HttpMethod: http.MethodPost,
		CreateURL: func(d *schema.ResourceData, c *client.Client) string {
			return fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts", c.ControlPlane)
		},
		NewResourceData: func() ResourceData { return &CreateGenericSAMLDraftRequest{} },
		NewResponseData: func(_ *schema.ResourceData) ResponseData { return &GenericSAMLDraftResponse{} },
	}
}

func ReadGenericSAMLDraftConfig() ResourceOperationConfig {
	return ResourceOperationConfig{
		Name:       "GenericSAMLDraftResourceRead",
		HttpMethod: http.MethodGet,
		CreateURL: func(d *schema.ResourceData, c *client.Client) string {
			return fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts/%s", c.ControlPlane, d.Id())
		},
		RequestErrorHandler: &readGenericSAMLDraftErrorHandler{},
		NewResponseData:     func(_ *schema.ResourceData) ResponseData { return &GenericSAMLDraftResponse{} },
	}
}

func DeleteGenericSAMLDraftConfig() ResourceOperationConfig {
	return ResourceOperationConfig{
		Name:       "GenericSAMLDraftResourceDelete",
		HttpMethod: http.MethodDelete,
		CreateURL: func(d *schema.ResourceData, c *client.Client) string {
			return fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts/%s", c.ControlPlane, d.Id())
		},
		RequestErrorHandler: &DeleteIgnoreHttpNotFound{resName: "SAML draft"},
	}
}

func resourceIntegrationIdPSAMLDraft() *schema.Resource {
	return &schema.Resource{
		Description: "Manages SAML IdP integration drafts.",
		CreateContext: CreateResource(
			CreateGenericSAMLDraftConfig(),
			ReadGenericSAMLDraftConfig(),
		),
		ReadContext:   ReadResource(ReadGenericSAMLDraftConfig()),
		DeleteContext: DeleteResource(DeleteGenericSAMLDraftConfig()),
		Schema: map[string]*schema.Schema{
			// All of the input arguments must force recreation of
			// the resource, because the API does not support
			// updates. If you try to use the Create API to do
			// updates, it will create a new SAML draft altogether,
			// generating a new ID etc.
			"display_name": {
				Description:  "Display name used in the Cyral control plane.",
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringIsNotEmpty,
				ForceNew:     true,
			},
			"disable_idp_initiated_login": {
				Description: "Whether or not IdP-Initiated login should be disabled for this generic SAML integration draft. Defaults to `false`.",
				Type:        schema.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Default:     false,
			},
			"idp_type": {
				Description: "Identity provider type. The value provided can be used as a filter when retrieving SAML integrations. See data source `cyral_integration_idp_saml`.",
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Default:     "saml-provider",
			},
			"attributes": {
				Description: "SAML Attribute names for the identity attributes required by the Cyral SP. Each attribute name MUST be at least 3 characters long.",
				Type:        schema.TypeSet,
				Optional:    true,
				ForceNew:    true,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"first_name": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users first name (given name). Defaults to `firstName`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      defaultUserAttributeFirstName,
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"last_name": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users last name (family name). Defaults to `lastName`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      defaultUserAttributeLastName,
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"email": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users email address. Defaults to `email`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      defaultUserAttributeEmail,
							ValidateFunc: validationStringLenAtLeast(3),
						},
						"groups": {
							Description:  "The name of the attribute in the incoming SAML assertion containing the users group membership in the IdP. Defaults to `memberOf`.",
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							Default:      defaultUserAttributeGroups,
							ValidateFunc: validationStringLenAtLeast(3),
						},
					},
				},
			},
			"sp_metadata": {
				Description: "The SP Metadata document describing the Cyral service provider for this integration.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			"id": {
				Description: "ID of this resource in the Cyral environment.",
				Type:        schema.TypeString,
				Computed:    true,
			},
			// toggle_recreation is used to recreate the SAML draft
			// in case a SAML integration that points to it is
			// deleted, but the SAML draft remains dangling in the
			// Terraform configuration. In this case, the object
			// wouldn't exist in the API, only in the Terraform
			// configuration. To help the user get out of this
			// situation, we force its recreation when he attempts
			// `terraform apply` again.
			"toggle_recreation": {
				Description: "Internal use only. Used to recreate the resource in case it reaches an inconsistent state.",
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     false,
				ForceNew:    true,
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

type readGenericSAMLDraftErrorHandler struct {
}

func (h *readGenericSAMLDraftErrorHandler) HandleError(
	d *schema.ResourceData,
	c *client.Client,
	err error,
) error {
	httpError, ok := err.(*client.HttpError)
	if !ok || httpError.StatusCode != http.StatusNotFound {
		return err
	}
	log.Printf("[DEBUG] SAML draft not found. Checking if completed draft exists.")

	query := urlQuery(map[string]string{
		"includeCompletedDrafts": "true",
		"displayName":            d.Get("display_name").(string),
		"idpType":                d.Get("idp_type").(string),
	})
	url := fmt.Sprintf("https://%s/v1/integrations/generic-saml/drafts%s",
		c.ControlPlane, query)
	body, err := c.DoRequest(url, http.MethodGet, nil)
	if err != nil {
		return fmt.Errorf("unable to read completed drafts: %w", err)
	}

	resp := ListGenericSAMLDraftsResponse{}
	if err := json.Unmarshal(body, &resp); err != nil {
		return fmt.Errorf("when reading completed drafts: "+
			"unable to unmarshall JSON: %w", err)
	}

	myID := d.Id()
	found := false
	for _, draft := range resp.Drafts {
		if draft.ID == myID {
			found = true
			break
		}
	}
	if !found {
		log.Printf("[DEBUG] Completed draft with ID %q "+
			"not found. Triggering recreation.", myID)
		currentToggle := d.Get("toggle_recreation").(bool)
		newToggle := !currentToggle
		if err := d.Set("toggle_recreation", newToggle); err != nil {
			return fmt.Errorf("error forcing recreation of SAML draft: %w", err)
		}
	} else {
		log.Printf("[DEBUG] Found completed draft with ID %q.", myID)
	}
	return nil
}
