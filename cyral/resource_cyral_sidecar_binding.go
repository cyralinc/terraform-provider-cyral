package cyral

type SidecarBinding struct {
	// SidecarId is the ID of the sidecar, must match an existing sidecar
	SidecarId string `json:"-"`
	// Id is the (immutable) ID of the binding. Generated by API on creation of Binding config
	Id string `json:"id"`
	// RepoId is the (immutable) ID of the repo. Need to match an existing repo.
	RepoId string `json:"repoId"`
	// Enabled indicates whether the listed bindings are enabled or not.
	// When disabled, the binding is not routable (port is either closed, or if multiplexed the binding is excluded from routable list).
	Enabled bool `json:"enabled"`
	// ListenerBindings contains the configuration for the bindings for the sidecar.
	ListenerBindings []ListenerBinding `json:"listenerBindings"`
}

// ListenerBinding holds a Listener reference and any binding specific settings for the listener of this repo.
type ListenerBinding struct {
	// ListenerId is a reference to the listener that this binding is associated with.
	ListenerId string `json:"listenerId"`
	// NodeIndex is the index of the repo node that this binding is associated with. Within range [0, N-1] where N is the number of nodes in the repo.
	NodeIndex int `json:"nodeIndex"`
}

// SidecarBindingResource represents the payload of a create or update a listener request
type SidecarBindingResource struct {
	ListenerConfig SidecarListener `json:"listenerConfig"`
}

/*
// resourceSidecarBinding returns the schema and methods for provisioning a sidecar binding
// Sidecar bindings API is {{baseURL}}/sidecars/:sidecarID/bindings/:bindingID
// GET {{baseURL}}/sidecars/:sidecarID/bindings/:bindingID (Get one binding)
// POST {{baseURL}}/sidecars/:sidecarID/bindings/ (Create a binding)
// PUT {{baseURL}}/sidecars/:sidecarID/bindings/:bindingID (Update a binding)
// DELETE {{baseURL}}/sidecars/:sidecarID/bindings/:bindingID (Delete a binding)
func resourceSidecarBinding() *schema.Resource {
	return &schema.Resource{
		Description: "Manages [sidecar bindings](https://cyral.com/docs/sidecars/sidecar-bindings).",
		CreateContext: CreateResource(
			ResourceOperationConfig{
				Name:       "SidecarBindingsResourceCreate",
				HttpMethod: http.MethodPost,
				CreateURL: func(d *schema.ResourceData, c *client.Client) string {
					return fmt.Sprintf("https://%s/v1/sidecars/%s/bindings",
						c.ControlPlane,
						d.Get("sidecar_id").(string))

				},
				NewResourceData: func() ResourceData { return &SidecarBindingResource{} },
				NewResponseData: func(_ *schema.ResourceData) ResponseData { return &CreateBindingAPIResponse{} },
			}, ReadSidecarBindingsConfig,
		),
		ReadContext: ReadResource(ReadSidecarBindingsConfig),
		UpdateContext: UpdateResource(
			ResourceOperationConfig{
				Name:       "SidecarBindingsResourceUpdate",
				HttpMethod: http.MethodPut,
				CreateURL: func(d *schema.ResourceData, c *client.Client) string {
					return fmt.Sprintf("https://%s/v1/sidecars/%s/bindings/%s",
						c.ControlPlane,
						d.Get("sidecar_id").(string),
						d.Id())

				},
				NewResourceData: func() ResourceData { return &SidecarBindingResource{} },
			}, ReadSidecarBindingsConfig,
		),
		DeleteContext: DeleteResource(
			ResourceOperationConfig{
				Name:       "SidecarBindingsResourceDelete",
				HttpMethod: http.MethodDelete,
				CreateURL: func(d *schema.ResourceData, c *client.Client) string {
					return fmt.Sprintf("https://%s/v1/sidecars/%s/bindings/%s",
						c.ControlPlane,
						d.Get("sidecar_id").(string),
						d.Get("binding_id").(string))
				},
			},
		),
		Schema: map[string]*schema.Schema{
			"binding_id": {
				Description: "ID of the binding that will be bound to the sidecar.",
				Type:        schema.TypeString,
				ForceNew:    true,
				Computed:    true,
			},
			"sidecar_id": {
				Description: "ID of the sidecar that the binding will be bound to.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			"repo_types": {
				Description: "List of repository types that the binding supports. Currently limited to one repo type, eg [\"mysql\"]",
				Type:        schema.TypeList,
				Required:    true,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"unix_binding_file": {
				Description: "File in which the sidecar will listen for the given repository. Required for unix bindings and mutual exclusive with tcp_binding_port.",
				Type:        schema.TypeString,
				Optional:    true,
			},
			"tcp_binding_port": {
				Description: "Port in which the sidecar will listen for the given repository. Required for tcp bindings and mutual exclusive with unix_binding_file.",
				Type:        schema.TypeInt,
				Optional:    true,
			},
			"tcp_binding_host": {
				Description: "Host in which the sidecar will listen for the given repository. Omit to listen on all interfaces.",
				Type:        schema.TypeString,
				Optional:    true,
			},
			"multiplexed": {
				Description: "Multiplexed binding, defaults to not multiplexing (false). Not supported for all repository types.",
				Type:        schema.TypeBool,
				Optional:    true,
			},
			"mysql_settings_db_version": {
				Description: "MySQL DB version. Required (and only relevant) for multiplexed bindings of type mysql",
				Type:        schema.TypeString,
				Optional:    true,
			},
			"mysql_settings_character_set": {
				Description: "MySQL character set. Optional and only relevant for multiplexed bindings of type mysql.",
				Type:        schema.TypeString,
				Optional:    true,
			},
			"s3_settings_proxy_mode": {
				Description: "S3 proxy mode, only relevant for S3 bindings. Defaults to false.",
				Type:        schema.TypeBool,
				Optional:    true,
			},
			"dynamodb_settings_proxy_mode": {
				Description: "DynamoDB proxy mode, only relevant for DynamoDB bindings. Defaults to false.",
				Type:        schema.TypeBool,
				Optional:    true,
			},
		},
		Importer: &schema.ResourceImporter{
			StateContext: func(
				ctx context.Context,
				d *schema.ResourceData,
				m interface{},
			) ([]*schema.ResourceData, error) {
				ids, err := unmarshalComposedID(d.Id(), "-", 2)
				if err != nil {
					return nil, err
				}
				_ = d.Set("sidecar_id", ids[0])
				d.SetId(ids[1])
				return []*schema.ResourceData{d}, nil
			},
		},
	}
}
*/
